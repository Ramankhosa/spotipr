generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = "postgresql://postgres:123@localhost:5432/spotipr"
}

enum TenantStatus {
  ACTIVE
  SUSPENDED
}

enum UserRole {
  SUPER_ADMIN
  OWNER
  ADMIN
  MANAGER
  ANALYST
  VIEWER
}

enum UserStatus {
  ACTIVE
  SUSPENDED
}

enum ATITokenStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
  ISSUED
  REVOKED
  EXPIRED
  USED_UP
}

model Tenant {
  id        String       @id @default(cuid())
  name      String
  atiId     String       @unique
  status    TenantStatus @default(ACTIVE)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  users     User[]
  atiTokens ATIToken[]
  auditLogs AuditLog[]

  // Metering relations
  tenantPlans       TenantPlan[]
  usageReservations UsageReservation[]
  usageMeters       UsageMeter[]
  usageLogs         UsageLog[]
  quotaAlerts       QuotaAlert[]

  // Drafting relations
  draftingSessions DraftingSession[]

  @@map("tenants")
}

model User {
  id               String     @id @default(cuid())
  tenantId         String?
  signupAtiTokenId String? // Track which ATI token was used for signup
  email            String     @unique
  passwordHash     String?
  name             String?
  role             UserRole   @default(ANALYST)
  status           UserStatus @default(ACTIVE)
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt

  tenant                  Tenant?                 @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  signupAtiToken          ATIToken?               @relation("SignupATIToken", fields: [signupAtiTokenId], references: [id])
  projects                Project[]
  collaborations          ProjectCollaborator[]
  patents                 Patent[]
  annexureVersions        AnnexureVersion[]
  auditLogs               AuditLog[]
  usageLogs               UsageLog[]
  createdPriorArtBundles  PriorArtSearchBundle[]  @relation("PriorArtBundleCreator")
  approvedPriorArtBundles PriorArtSearchBundle[]  @relation("PriorArtBundleApprover")
  priorArtHistory         PriorArtSearchHistory[]
  priorArtRuns            PriorArtRun[]
  credits                 UserCredit?
  noveltyAssessments      NoveltyAssessmentRun[]
  draftingSessions       DraftingSession[]
  draftingHistory        DraftingHistory[]

  @@map("users")
}

model ATIToken {
  id             String         @id @default(cuid())
  tenantId       String?
  tokenHash      String
  rawToken       String? // Encrypted raw token for revelation (temporary)
  rawTokenExpiry DateTime? // When raw token can no longer be revealed
  fingerprint    String
  status         ATITokenStatus @default(ISSUED)
  expiresAt      DateTime?
  maxUses        Int?
  usageCount     Int            @default(0)
  planTier       String?
  notes          String?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  tenant      Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  signupUsers User[]  @relation("SignupATIToken")

  @@map("ati_tokens")
}

model AuditLog {
  id          String   @id @default(cuid())
  actorUserId String?
  tenantId    String?
  action      String
  resource    String
  ip          String?
  meta        Json?
  createdAt   DateTime @default(now())

  actor  User?   @relation(fields: [actorUserId], references: [id], onDelete: SetNull)
  tenant Tenant? @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@map("audit_logs")
}

model Project {
  id               String                @id @default(cuid())
  name             String
  userId           String
  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt
  applicantProfile ApplicantProfile?
  collaborators    ProjectCollaborator[]
  patents          Patent[]
  user             User                  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("projects")
}

model ApplicantProfile {
  id                         String            @id @default(cuid())
  projectId                  String            @unique
  applicantLegalName         String
  applicantCategory          ApplicantCategory
  applicantAddressLine1      String
  applicantAddressLine2      String?
  applicantCity              String
  applicantState             String
  applicantCountryCode       String
  applicantPostalCode        String
  correspondenceName         String
  correspondenceEmail        String
  correspondencePhone        String
  correspondenceAddressLine1 String
  correspondenceAddressLine2 String?
  correspondenceCity         String
  correspondenceState        String
  correspondenceCountryCode  String
  correspondencePostalCode   String
  useAgent                   Boolean           @default(false)
  agentName                  String?
  agentRegistrationNo        String?
  agentEmail                 String?
  agentPhone                 String?
  agentAddressLine1          String?
  agentAddressLine2          String?
  agentCity                  String?
  agentState                 String?
  agentCountryCode           String?
  agentPostalCode            String?
  defaultJurisdiction        Jurisdiction
  defaultRoute               FilingRoute
  defaultLanguage            String            @default("EN")
  defaultEntityStatusIn      EntityStatus
  createdAt                  DateTime          @default(now())
  updatedAt                  DateTime          @updatedAt
  project                    Project           @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@map("applicant_profiles")
}

model ProjectCollaborator {
  id        String   @id @default(cuid())
  projectId String
  userId    String
  role      String   @default("collaborator") // owner, collaborator, viewer
  addedBy   String // userId of who added this collaborator
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([projectId, userId])
  @@map("project_collaborators")
}

enum ApplicantCategory {
  natural_person
  small_entity
  startup
  others
}

enum Jurisdiction {
  IN
  PCT
  US
  EP
}

enum FilingRoute {
  national
  pct_international
  pct_national
}

enum EntityStatus {
  startup
  small_entity
  university
  regular
}

enum PlanStatus {
  ACTIVE
  INACTIVE
  DEPRECATED
}

enum FeatureCode {
  PRIOR_ART_SEARCH
  PATENT_DRAFTING
  DIAGRAM_GENERATION
  EMBEDDINGS
  RERANK
}

enum TaskCode {
  LLM1_PRIOR_ART
  LLM2_DRAFT
  LLM3_DIAGRAM
  LLM4_NOVELTY_SCREEN
  LLM5_NOVELTY_ASSESS
}

enum ModelClass {
  BASE_S
  BASE_M
  PRO_M
  PRO_L
  ADVANCED
}

model Patent {
  id               String                 @id @default(cuid())
  projectId        String
  title            String
  createdBy        String
  createdAt        DateTime               @default(now())
  updatedAt        DateTime               @updatedAt
  annexureVersions AnnexureVersion[]
  jobs             Job[]
  priorArtBundles  PriorArtSearchBundle[]
  noveltyAssessments NoveltyAssessmentRun[]
  draftingSessions DraftingSession[]

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)
  creator User    @relation(fields: [createdBy], references: [id])

  @@map("patents")
}

model AnnexureVersion {
  id        String   @id @default(cuid())
  patentId  String
  rev       Int      @default(1)
  html      String
  textPlain String
  createdBy String
  createdAt DateTime @default(now())

  patent  Patent @relation(fields: [patentId], references: [id], onDelete: Cascade)
  creator User   @relation(fields: [createdBy], references: [id])

  @@map("annexure_versions")
}

enum JobType {
  DRAFTING
  PRIOR_ART
}

enum JobStatus {
  QUEUED
  PROCESSING
  COMPLETED
  FAILED
}

model Job {
  id            String    @id @default(cuid())
  patentId      String
  type          JobType
  status        JobStatus @default(QUEUED)
  config        Json? // JSON configuration for the job
  resultSummary Json? // JSON result summary
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  patent Patent @relation(fields: [patentId], references: [id], onDelete: Cascade)

  @@map("jobs")
}

model TokenNotification {
  id               String   @id @default(cuid())
  tokenId          String
  userId           String
  notificationType String // "7_days", "3_days", "1_day", "expired"
  sentAt           DateTime @default(now())
  deliveryMethod   String // "email"
  status           String // "sent", "delivered", "failed"
  emailSent        Boolean  @default(false)

  @@unique([tokenId, userId, notificationType])
  @@map("token_notifications")
}

// === METERING SYSTEM MODELS ===

model Plan {
  id        String     @id @default(cuid())
  code      String     @unique
  name      String
  cycle     String // e.g., "MONTHLY"
  status    PlanStatus @default(ACTIVE)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  tenantPlans   TenantPlan[]
  planFeatures  PlanFeature[]
  planLLMAccess PlanLLMAccess[]
  policyRules   PolicyRule[]

  @@map("plans")
}

model TenantPlan {
  id            String    @id @default(cuid())
  tenantId      String
  planId        String
  effectiveFrom DateTime
  expiresAt     DateTime?
  status        String    @default("ACTIVE")
  createdAt     DateTime  @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id])
  plan   Plan   @relation(fields: [planId], references: [id])

  @@unique([tenantId, planId, effectiveFrom])
  @@map("tenant_plans")
}

model Feature {
  id   String      @id @default(cuid())
  code FeatureCode @unique
  name String
  unit String // e.g., "calls", "tokens"

  planFeatures PlanFeature[]
  linkedTasks  Task[]
  usageMeters  UsageMeter[]
  usageLogs    UsageLog[]

  @@map("features")
}

model PlanFeature {
  id           String @id @default(cuid())
  planId       String
  featureId    String
  monthlyQuota Int?
  dailyQuota   Int?

  plan    Plan    @relation(fields: [planId], references: [id])
  feature Feature @relation(fields: [featureId], references: [id])

  @@unique([planId, featureId])
  @@map("plan_features")
}

model Task {
  id              String   @id @default(cuid())
  code            TaskCode @unique
  name            String
  linkedFeatureId String

  linkedFeature Feature         @relation(fields: [linkedFeatureId], references: [id])
  planLLMAccess PlanLLMAccess[]
  usageLogs     UsageLog[]

  @@map("tasks")
}

model LLMModelClass {
  id   String     @id @default(cuid())
  code ModelClass @unique
  name String

  planLLMAccess PlanLLMAccess[]

  @@map("llm_model_classes")
}

model PlanLLMAccess {
  id             String   @id @default(cuid())
  planId         String
  taskCode       TaskCode
  allowedClasses String // JSON array of ModelClass codes
  defaultClassId String // Reference to LLMModelClass

  plan         Plan          @relation(fields: [planId], references: [id])
  task         Task          @relation(fields: [taskCode], references: [code])
  defaultClass LLMModelClass @relation(fields: [defaultClassId], references: [id])

  @@unique([planId, taskCode])
  @@map("plan_llm_access")
}

model PolicyRule {
  id       String    @id @default(cuid())
  scope    String // "plan" or "tenant"
  scopeId  String // plan_id or tenant_id
  taskCode TaskCode?
  key      String // max_tokens_in, max_tokens_out, etc.
  value    Int

  plan Plan? @relation(fields: [scopeId], references: [id])

  @@unique([scope, scopeId, taskCode, key])
  @@map("policy_rules")
}

model UsageReservation {
  id             String    @id @default(cuid())
  tenantId       String
  featureId      String?
  taskCode       TaskCode?
  reservedUnits  Int
  status         String    @default("PENDING") // PENDING, ACTIVE, RELEASED, EXPIRED
  expiresAt      DateTime
  idempotencyKey String    @unique
  createdAt      DateTime  @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@map("usage_reservations")
}

model UsageMeter {
  id           String    @id @default(cuid())
  tenantId     String
  featureId    String?
  taskCode     TaskCode?
  periodType   String // DAILY, MONTHLY
  periodKey    String // e.g., "2024-01", "2024-01-15"
  currentUsage Int       @default(0)
  lastUpdated  DateTime  @default(now())

  tenant  Tenant   @relation(fields: [tenantId], references: [id])
  feature Feature? @relation(fields: [featureId], references: [id])

  @@unique([tenantId, featureId, taskCode, periodType, periodKey])
  @@map("usage_meters")
}

model UsageLog {
  id             String    @id @default(cuid())
  tenantId       String
  userId         String?
  featureId      String?
  taskCode       TaskCode?
  modelClass     String? // ModelClass code
  apiCode        String? // PATENT_OPEN, NPL_OPEN, etc.
  inputTokens    Int?
  outputTokens   Int?
  apiCalls       Int?      @default(1)
  startedAt      DateTime  @default(now())
  completedAt    DateTime?
  status         String // PENDING, COMPLETED, FAILED
  error          String?
  idempotencyKey String?
  reservationId  String?

  tenant  Tenant   @relation(fields: [tenantId], references: [id])
  user    User?    @relation(fields: [userId], references: [id])
  feature Feature? @relation(fields: [featureId], references: [id])
  task    Task?    @relation(fields: [taskCode], references: [code])

  @@map("usage_logs")
}

model QuotaAlert {
  id         String    @id @default(cuid())
  tenantId   String
  featureId  String?
  taskCode   TaskCode?
  alertType  String // QUOTA_80, QUOTA_100, CONCURRENCY_LIMIT
  threshold  Int
  notifiedAt DateTime  @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@map("quota_alerts")
}

// === PRIOR ART SEARCH MODELS ===

enum PriorArtSearchMode {
  LLM
  MANUAL
}

enum PriorArtSearchStatus {
  DRAFT
  READY_FOR_REVIEW
  APPROVED
  ARCHIVED
}

enum PriorArtQueryLabel {
  BROAD
  BASELINE
  NARROW
}

model PriorArtSearchBundle {
  id       String               @id @default(cuid())
  patentId String
  mode     PriorArtSearchMode
  status   PriorArtSearchStatus @default(DRAFT)

  // Input data
  briefRaw       String? // Raw invention brief (LLM mode)
  inventionBrief String // Processed brief (max 200 words)

  // Generated/Edited data (JSON schema validated)
  bundleData Json // Complete JSON bundle per SRS schema

  // Metadata
  createdBy  String
  approvedBy String?
  approvedAt DateTime?
  version    String    @default("v1.0") // Semantic versioning
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  // Relations
  patent        Patent                  @relation(fields: [patentId], references: [id], onDelete: Cascade)
  creator       User                    @relation("PriorArtBundleCreator", fields: [createdBy], references: [id])
  approver      User?                   @relation("PriorArtBundleApprover", fields: [approvedBy], references: [id])
  history       PriorArtSearchHistory[]
  queryVariants PriorArtQueryVariant[]
  runs          PriorArtRun[]

  @@map("prior_art_search_bundles")
}

model PriorArtSearchHistory {
  id           String   @id @default(cuid())
  bundleId     String
  action       String // BRIEF_SUBMITTED, LLM_GENERATED, EDITED, VALIDATION_FAILED, etc.
  userId       String
  timestamp    DateTime @default(now())
  previousData Json? // Previous state for diffing
  newData      Json? // New state for diffing
  notes        String? // Optional notes about the change

  bundle PriorArtSearchBundle @relation(fields: [bundleId], references: [id], onDelete: Cascade)
  user   User                 @relation(fields: [userId], references: [id])

  @@map("prior_art_search_history")
}

model PriorArtQueryVariant {
  id        String             @id @default(cuid())
  bundleId  String
  label     PriorArtQueryLabel
  query     String // The actual search query
  num       Int                @default(20) // Results per page
  page      Int                @default(1) // Starting page
  notes     String // Strategy notes
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt

  bundle PriorArtSearchBundle @relation(fields: [bundleId], references: [id], onDelete: Cascade)

  @@unique([bundleId, label])
  @@map("prior_art_query_variants")
}

// === PRIOR ART SEARCH EXECUTION MODELS ===

enum PriorArtRunStatus {
  RUNNING
  COMPLETED
  COMPLETED_WITH_WARNINGS
  FAILED
  CREDIT_EXHAUSTED
}

model PriorArtRun {
  id             String            @id @default(cuid())
  bundleId       String
  bundleHash     String // Hash of approved bundle for integrity
  approvedBundle Json // Frozen approved bundle data
  status         PriorArtRunStatus @default(RUNNING)

  // User and credit tracking
  userId          String
  creditsConsumed Int      @default(1) // Always 1 credit per search
  apiCallsMade    Int      @default(0) // Actual API calls made
  costEstimate    Decimal? @db.Decimal(10, 4)

  // Timing
  startedAt  DateTime  @default(now())
  finishedAt DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  // Relations
  bundle                PriorArtSearchBundle            @relation(fields: [bundleId], references: [id], onDelete: Cascade)
  user                  User                            @relation(fields: [userId], references: [id])
  queryVariants         PriorArtQueryVariantExecution[]
  rawResults            PriorArtRawResult[]
  // unifiedResults removed - no longer needed
  variantHits           PriorArtVariantHit[]
  PriorArtUnifiedResult PriorArtUnifiedResult[]

  // Level 0 local-database screening
  level0Checked       Boolean              @default(false)
  level0Determination NoveltyDetermination?
  level0Results       Json?
  level0ReportUrl     String?

  @@map("prior_art_runs")
}

model PriorArtQueryVariantExecution {
  id           String             @id @default(cuid())
  runId        String
  label        PriorArtQueryLabel
  query        String // Actual query executed
  num          Int                @default(20)
  pageTarget   Int                @default(1)
  pageExecuted Int                @default(1)
  apiCalls     Int                @default(0) // API calls for this variant
  resultsCount Int                @default(0)
  executedAt   DateTime           @default(now())

  run PriorArtRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@unique([runId, label])
  @@map("prior_art_query_variant_executions")
}

model PriorArtRawResult {
  id         String   @id @default(cuid())
  runId      String
  variantId  String // PriorArtQueryVariantExecution.id
  pageNo     Int      @default(1)
  payload    Json // Raw SerpAPI response
  receivedAt DateTime @default(now())

  run PriorArtRun @relation(fields: [runId], references: [id], onDelete: Cascade)

  @@map("prior_art_raw_results")
}

model PriorArtRawDetail {
  id                String   @id @default(cuid())
  publicationNumber String // Normalized patent number
  patentId          String // SerpAPI patent ID (patent/US123/en or scholar/...)
  payload           Json // Raw SerpAPI details response
  fetchedAt         DateTime @default(now())

  @@unique([publicationNumber, patentId])
  @@map("prior_art_raw_details")
}

model PriorArtPatent {
  publicationNumber String    @id
  title             String?
  abstract          String?
  language          String?
  publicationDate   DateTime?
  priorityDate      DateTime?
  filingDate        DateTime?

  // Arrays stored as JSONB for flexibility
  assignees String[] // JSON array in DB
  inventors String[] // JSON array in DB
  cpcs      String[] // JSON array in DB
  ipcs      String[] // JSON array in DB

  link    String?
  pdfLink String?
  extras  Json? // Additional fields

  firstSeenAt DateTime @default(now())
  lastSeenAt  DateTime @updatedAt

  // Relations
  variantHits PriorArtVariantHit[]
  details     PriorArtPatentDetail?
  // unifiedResults removed - relationship no longer exists

  @@map("prior_art_patents")
}

model PriorArtVariantHit {
  id                String   @id @default(cuid())
  runId             String
  variantId         String // PriorArtQueryVariantExecution.id
  publicationNumber String
  rankInVariant     Int // Position in variant results
  snippet           String? // Search result snippet
  foundAt           DateTime @default(now())

  run    PriorArtRun    @relation(fields: [runId], references: [id], onDelete: Cascade)
  patent PriorArtPatent @relation(fields: [publicationNumber], references: [publicationNumber])

  @@unique([runId, variantId, publicationNumber])
  @@map("prior_art_variant_hits")
}

model PriorArtPatentDetail {
  publicationNumber     String   @id
  claims                Json? // Full claims as JSONB
  description           String?
  classifications       Json? // Structured classifications
  worldwideApplications Json? // Filing data
  events                Json? // Legal events
  legalEvents           Json? // Additional events
  citationsPatent       Json? // Patent citations
  citationsNPL          Json? // Non-patent literature citations
  pdfLink               String?
  fetchedAt             DateTime @default(now())

  patent PriorArtPatent @relation(fields: [publicationNumber], references: [publicationNumber])

  @@map("prior_art_patent_details")
}

enum PriorArtIntersectionType {
  NONE // Found in only one variant
  I2 // Found in any 2 variants
  I3 // Found in all 3 variants
}

model PriorArtUnifiedResult {
  id                String              @id @default(cuid())
  runId             String
  publicationNumber String // Keep existing field for backward compatibility
  contentType       PriorArtContentType @default(PATENT) // PATENT or SCHOLAR
  scholarIdentifier String? // Optional field for scholar content identifiers
  foundInVariants   String[] // Array of variant labels: ["BROAD", "BASELINE", "NARROW"]

  // Ranks in each variant (null if not found)
  rankBroad    Int?
  rankBaseline Int?
  rankNarrow   Int?

  intersectionType PriorArtIntersectionType
  score            Decimal                  @db.Decimal(5, 4) // 0.0000 to 1.0000
  shortlisted      Boolean                  @default(false)

  createdAt DateTime @default(now())

  run PriorArtRun @relation(fields: [runId], references: [id], onDelete: Cascade)
  // patent relationship removed - handle in application logic based on contentType

  @@unique([runId, publicationNumber])
  @@map("prior_art_unified_results")
}

model PriorArtScholarContent {
  identifier    String   @id
  title         String?
  authors       String[] // Array of author names
  publication   String? // Journal/conference name
  year          Int?
  abstract      String?
  citationCount Int?
  link          String? // Link to the article
  pdfLink       String? // Link to PDF if available
  doi           String? // Digital Object Identifier
  source        String? // Google Scholar, IEEE, ACM, etc.
  fetchedAt     DateTime @default(now())

  @@map("prior_art_scholar_content")
}

// === LOCAL PATENT DATASET (e.g., Indian patents) ===
model LocalPatent {
  id                Int      @id @default(autoincrement())
  publicationNumber String   @unique
  kind              String?
  title             String
  abstract          String?
  abstractOriginal  String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("local_patents")
}

// === NOVELTY ASSESSMENT MODELS ===

enum NoveltyAssessmentStatus {
  PENDING
  STAGE1_SCREENING
  STAGE1_COMPLETED
  STAGE2_ASSESSMENT
  STAGE2_COMPLETED
  NOVEL
  NOT_NOVEL
  DOUBT_RESOLVED
  FAILED
}

enum NoveltyDetermination {
  NOVEL
  NOT_NOVEL
  PARTIALLY_NOVEL // Some aspects novel, others not
  DOUBT // Requires further analysis
}

enum NoveltyAssessmentStage {
  STAGE1_SCREENING
  STAGE2_ASSESSMENT
}

model NoveltyAssessmentRun {
  id                String                  @id @default(cuid())
  patentId          String
  runId             String? // Link to prior art run that provided intersecting patents
  userId            String
  status            NoveltyAssessmentStatus @default(PENDING)

  // Input data
  inventionSummary  Json // Invention summary (title, problem, solution)
  intersectingPatents Json // Array of {publicationNumber, title, abstract, relevance?}

  // Stage 1 results (screening)
  stage1CompletedAt DateTime?
  stage1Results     Json? // Array of {publicationNumber, relevance, determination, confidence}

  // Stage 2 results (detailed assessment)
  stage2CompletedAt DateTime?
  stage2Results     Json? // Array of {publicationNumber, determination, remarks, suggestions}

  // Final determination
  finalDetermination NoveltyDetermination?
  finalRemarks       String?
  finalSuggestions   String?

  // Metadata
  createdAt          DateTime                @default(now())
  updatedAt          DateTime                @updatedAt

  // Relations
  patent Patent @relation(fields: [patentId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id])
  llmCalls NoveltyAssessmentLLMCall[]

  @@map("novelty_assessment_runs")
}

model NoveltyAssessmentLLMCall {
  id              String                 @id @default(cuid())
  assessmentId    String
  stage           NoveltyAssessmentStage
  taskCode        TaskCode
  prompt          String
  response        Json?
  tokensUsed      Int?
  modelClass      String?
  determination   NoveltyDetermination?
  remarks         String?
  suggestions     String?
  calledAt        DateTime               @default(now())

  // Relations
  assessment NoveltyAssessmentRun @relation(fields: [assessmentId], references: [id], onDelete: Cascade)

  @@map("novelty_assessment_llm_calls")
}


enum PriorArtContentType {
  PATENT
  SCHOLAR
}

enum DraftingSessionStatus {
  IDEA_ENTRY
  COMPONENT_PLANNER
  FIGURE_PLANNER
  DIAGRAM_GENERATOR
  ANNEXURE_DRAFT
  REVIEW_FIX
  EXPORT_READY
  COMPLETED
}

enum ComponentType {
  MAIN_CONTROLLER
  SUBSYSTEM
  MODULE
  INTERFACE
  SENSOR
  ACTUATOR
  PROCESSOR
  MEMORY
  DISPLAY
  COMMUNICATION
  POWER_SUPPLY
  OTHER
}

enum NumeralRange {
  HUNDREDS // 100-199: Main components
  TWO_HUNDREDS // 200-299: Sub-components
  THREE_HUNDREDS // 300-399: Modules
  FOUR_HUNDREDS // 400-499: Interfaces
  FIVE_HUNDREDS // 500-599: Sensors/Actuators
  SIX_HUNDREDS // 600-699: Processors
  SEVEN_HUNDREDS // 700-799: Memory
  EIGHT_HUNDREDS // 800-899: Displays
  NINE_HUNDREDS // 900-999: Other
}

model DraftingSession {
  id        String                @id @default(cuid())
  patentId  String
  userId    String
  tenantId  String?
  status    DraftingSessionStatus @default(IDEA_ENTRY)

  // Metadata
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  completedAt  DateTime?

  // Relations
  patent     Patent         @relation(fields: [patentId], references: [id], onDelete: Cascade)
  user       User           @relation(fields: [userId], references: [id])
  tenant     Tenant?        @relation(fields: [tenantId], references: [id], onDelete: SetNull)
  ideaRecord IdeaRecord?
  referenceMap ReferenceMap?
  figurePlans FigurePlan[]
  diagramSources DiagramSource[]
  annexureDrafts AnnexureDraft[]
  history    DraftingHistory[]

  @@map("drafting_sessions")
}

model IdeaRecord {
  id              String   @id @default(cuid())
  sessionId       String   @unique
  title           String
  rawInput        String // Original user input
  normalizedData  Json // Structured JSON with all fields

  // Extracted fields for easy querying
  problem         String?
  objectives      String?
  components      Json? // Array of component descriptions
  logic           String?
  inputs          String?
  outputs         String?
  variants        String?
  bestMethod      String?

  // LLM metadata
  llmPromptUsed   String?
  llmResponse     Json?
  tokensUsed      Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  session DraftingSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@map("idea_records")
}

model ReferenceMap {
  id         String   @id @default(cuid())
  sessionId  String   @unique
  components Json // Array of {id, name, type, description, numeral, range}

  // Validation
  isValid     Boolean  @default(false)
  validationErrors Json? // Array of validation issues

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  session DraftingSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@map("reference_maps")
}

model FigurePlan {
  id          String   @id @default(cuid())
  sessionId   String
  figureNo    Int
  title       String
  nodes       Json // Array of component references included in figure
  edges       Json // Array of {from, to, label} connections
  description String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  session DraftingSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@unique([sessionId, figureNo])
  @@map("figure_plans")
}

model DiagramSource {
  id           String   @id @default(cuid())
  sessionId    String
  figureNo     Int
  plantumlCode String
  checksum     String // For integrity verification

  // Uploaded image metadata
  imageFilename String?
  imagePath     String?
  imageChecksum String?
  imageUploadedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  session DraftingSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@unique([sessionId, figureNo])
  @@map("diagram_sources")
}

model AnnexureDraft {
  id          String   @id @default(cuid())
  sessionId   String
  version     Int      @default(1)

  // Draft sections
  title                    String
  fieldOfInvention        String?
  background              String?
  summary                 String?
  briefDescriptionOfDrawings String?
  detailedDescription     String?
  bestMethod             String?
  claims                  String?
  abstract                String?
  listOfNumerals          String?

  // Metadata
  fullDraftText String // Complete assembled draft
  isValid       Boolean @default(false)
  validationReport Json? // Consistency check results

  // LLM metadata
  llmPromptUsed String?
  llmResponse   Json?
  tokensUsed    Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  session DraftingSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@map("annexure_drafts")
}

model DraftingHistory {
  id          String   @id @default(cuid())
  sessionId   String
  action      String // IDEA_UPDATED, COMPONENTS_ASSIGNED, FIGURE_PLAN_CHANGED, etc.
  userId      String
  stage       DraftingSessionStatus

  // Data changes
  previousData Json?
  newData      Json?
  notes        String?

  timestamp DateTime @default(now())

  // Relations
  session DraftingSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  user    User           @relation(fields: [userId], references: [id])

  @@map("drafting_history")
}

model UserCredit {
  userId       String    @id // References User.id
  totalCredits Int       @default(100) // Monthly allowance
  usedCredits  Int       @default(0)
  monthlyReset DateTime // When credits reset
  lastSearchAt DateTime?
  planTier     String    @default("free") // free, basic, pro, enterprise

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_credits")
}
